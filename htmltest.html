result_detail.html :
{% extends 'auditor/auditor.html' %}
{% load static %}

{% block main %}
<div class="Container">
  <h1>Test Result Details</h1>
  <h2>{{ test_result }}</h2>
  <h3>{{ test_result.request }}</h3>
  <p>Nurse: {{ test_result.request.nurse.user.first_name }} {{ test_result.request.nurse.user.last_name }}</p>
  
  <h3>Tests:</h3>
  <ul>
    {% for test in test_result.request.tests.all %}
      <li>
        <h4>{{ test.test_offered.name }}</h4>
        <p>Value: {{ test.value }}</p>
        <p>Description: {{ test.description }}</p>
        <p>Components:</p>
        <ul>
          {% for component in test.components.all %}
            <li>{{ component.info.name }} - Value: {{ component.value }}</li>
          {% endfor %}
        </ul>
      </li>
    {% endfor %}
  </ul>

  
  {% if not test_result.approved %}
  <a href="{% url 'result_update' test_result.id %}">Modify Tests</a>
    <form method="POST" action="{% url 'approve_result' test_result.id %}">
        {% csrf_token %}
        <button type="submit" name="approve" >Approve Result</button>
    </form>
  {% else %}
    <p><strong>Approved !</strong></p>
  {% endif %}
</div>
{% endblock main %}

views :
@login_required
@permission_required('auditor.view_auditor', raise_exception=True)
def result_detail(request , test_result_id):
    test_result = get_object_or_404(TestResult, id=test_result_id)
    
        
    context = {
        'test_result': test_result,
    }

    return render(request,'auditor/result/result_detail.html', context)


@login_required
@permission_required('auditor.view_auditor', raise_exception=True)
def approve_result(request, test_result_id):
    
    if 'approve' in request.POST:
        test_result = get_object_or_404(TestResult, id=test_result_id)

        # Update the approval status of the test result
        test_result.approved = True
        test_result.save()
        

    return redirect('result_detail', test_result_id=test_result_id)

@login_required
@permission_required('auditor.view_auditor', raise_exception=True)
def result_update(request, test_result_id):
    test_result = get_object_or_404(TestResult, id=test_result_id)

    if request.method == 'POST':
        # Process the form submission to update the tests

        form = UpdateTestsForm(request.POST, test_result=test_result)
        if form.is_valid():
            # Iterate over the tests in the form data and update their values
            for test in test_result.request.tests.all():
                test_value_key = f'test_{test.id}_value'
                if test_value_key in form.cleaned_data:
                    test.value = form.cleaned_data[test_value_key]
                    test.save()

                    # Iterate over the components of the test and update their values
                    for component in test.components.all():
                        component_value_key = f'component_{component.id}_value'
                        if component_value_key in form.cleaned_data:
                            component.value = form.cleaned_data[component_value_key]
                            component.save()

            return redirect('result_detail', test_result_id=test_result_id)
    else:
        # Display the form for modifying tests

        form = UpdateTestsForm(test_result=test_result)

    context = {
        'test_result': test_result,
        'form': form,
    }

    return render(request, 'auditor/result/result_update.html', context)


class ComponentInformation(models.Model):
    name = models.CharField(max_length=50, unique=True)
    unit = models.CharField(max_length=45, null=True, blank=True)
    low_male_range = models.FloatField(null=True, blank=True)
    high_male_range = models.FloatField(null=True, blank=True)
    low_female_range = models.FloatField(null=True, blank=True)
    high_female_range = models.FloatField(null=True, blank=True)
    
    class Meta:
            db_table = 'component_info'
            verbose_name_plural = 'Component Info'
    
    def __str__(self):
        return self.name
    
class Component(models.Model):
    info = models.ForeignKey(ComponentInformation, on_delete=models.CASCADE)
    value = models.FloatField(null=True,blank=True)

    class Meta:
        db_table = 'component'
        
        
    def __str__(self):
        return f'{self.info.name} value:{self.value}'

class TestOffered(models.Model):
    name = models.CharField(max_length=50,unique=True)
    price = models.DecimalField(max_digits=10, decimal_places=2)

    class Meta:
        db_table = 'test_offered'
        verbose_name_plural = 'Offered Tests'
        
    def __str__(self):
        return self.name
            
class Test(models.Model):
    test_offered = models.ForeignKey(TestOffered,on_delete=models.CASCADE)
    components = models.ManyToManyField(Component)
    value = models.CharField(max_length=100)
    description = models.CharField(max_length=500, null=True, blank=True)
    confirmed = models.BooleanField(default=False)

    class Meta:
            db_table = 'test'
            verbose_name_plural = 'Tests Preformed'
            
    def __str__(self):
        return self.test_offered.name

class AnalysisRequest(models.Model):
    PENDING = 'pending'
    WORKING_ON = 'working-on'
    FINISHED = 'finished'
    
    STATUS_CHOICES = [
        (PENDING, 'Pending'),
        (WORKING_ON, 'Working On'),
        (FINISHED, 'Finished'),
    ]
    
    appointment = models.OneToOneField(Appointment, on_delete=models.CASCADE)
    nurse = models.ForeignKey(Nurse, on_delete=models.CASCADE)
    tests = models.ManyToManyField(Test)
    creation_time = models.DateTimeField(auto_now_add=True)
    start_time = models.DateTimeField(null=True, blank=True)
    finish_time = models.DateTimeField(null=True, blank=True)
    accepted = models.BooleanField(default=False)
    finished = models.BooleanField(default=False)
    status =  models.CharField(max_length=45, choices=STATUS_CHOICES, default=PENDING)
    
    def duration_unformated(self):
        if self.start_time :
            if self.finish_time:
                duration = self.finish_time - self.start_time
            else:
                duration = timezone.now() - self.start_time
            return duration
        
        return 0 
    
    def duration(self):
        if self.start_time:
            if self.finish_time:
                duration = self.finish_time - self.start_time
            else:
                duration = timezone.now() - self.start_time

            # Convert the duration to hours and minutes
            hours = duration // timedelta(hours=1)
            minutes = (duration % timedelta(hours=1)) // timedelta(minutes=1)

            return f"{hours} hours {minutes} minutes"

        return "0 hours 0 minutes"
    
    def all_tests_confirmed(self):
        return self.tests.filter(confirmed=False).count() == 0
    
    def save(self, *args, **kwargs):
        if self.accepted and not self.start_time:
            self.start_time = timezone.now()
            self.status = self.WORKING_ON
        if self.finished and not self.finish_time:
            self.finish_time = timezone.now()
            self.status = self.FINISHED
        super().save(*args, **kwargs)
    
    class Meta:
        db_table = 'analysis_request'
        
    def __str__(self):
        return f"{self.appointment.client.user.first_name} {self.appointment.client.user.last_name} - Analysis Requested #{self.id}"
    
    
    
class TestResult(models.Model):
    request = models.OneToOneField(AnalysisRequest, on_delete=models.CASCADE)
    creation_time = models.DateTimeField(auto_now_add=True)
    duration = models.DurationField(null=True, blank=True)
    approved = models.BooleanField(default=False)

    class Meta:
        db_table = 'test_result'
        
    def __str__(self):
        return f"Test Result #{self.id}"

forms:

class UpdateTestsForm(forms.Form):
    def __init__(self, *args, **kwargs):
        test_result = kwargs.pop('test_result')
        super().__init__(*args, **kwargs)
        
        # Iterate over the tests in the test result and create form fields for each test
        for test in test_result.request.tests.all():
            # Create a form field for the test value
            self.fields[f'test_{test.id}_value'] = forms.CharField(
                label=test.test_offered.name,
                initial=test.value,
                required=False
            )
            
            # Iterate over the components of the test and create form fields for each component
            for component in test.components.all():
                # Create a form field for the component value
                self.fields[f'component_{component.id}_value'] = forms.FloatField(
                    label=component.info.name,
                    initial=component.value,
                    required=False
                )



result_update.html:
{% extends 'auditor/auditor.html' %}
{% load static %}

{% block main %}
<div class="Container">
  <h1>Test Result Update</h1>
  {% if not test_result.approved %}
  <a href="{% url 'result_update' test_result.id %}">Modify Tests</a>
    <form method="POST" action="{% url 'approve_result' test_result.id %}">
        {% csrf_token %}
        {{ form.as_div}}
        <button type="submit" name="approve" >Approve Result</button>
    </form>
  {% else %}
    <p><strong>Can't Update Already Approved !</strong></p>
  {% endif %}
</div>
{% endblock main %}